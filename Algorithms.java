import java.util.*;

public class Algorithms
{
   public static void main(String[] args)
   {
	   Vertex a = new Vertex(0, false);
	   Vertex b = new Vertex(1, false);
	   Vertex c = new Vertex(2, false);
	   Vertex d = new Vertex(3, false);


	   Vertex[] vertices = {a, b, c, d};

	   Edge[][] edges = {
		   {new Edge(0, 1, 5), new Edge(0, 2, 6), new Edge(0, 3, 8)},
		   {new Edge(1, 0, 5), new Edge(1, 2, 10), new Edge(1, 3, 3)},
		   {new Edge(2, 0, 6), new Edge(2, 1, 10), new Edge(2, 3, 2)},
		   {new Edge(3, 0, 8), new Edge(3, 1, 3), new Edge(3, 2, 2)},
	   };

	   Graph graph = new Graph(vertices, edges);

	   int[] randomPath = new int[4];
	   randomPath = graph.random().clone();

	   System.out.println("The path generated by random method is: " + Arrays.toString(randomPath));

	   graph.reset();

	   System.out.println("The best path generated by iterative method is: " + Arrays.toString(graph.iterative()) + "\n");

	   graph.reset();

	   System.out.println("The path generated by greedy algorithm is: " + Arrays.toString(graph.greedy()));

	   System.out.println("The path generated by greedy optimization algorithm is: " + Arrays.toString(graph.greedyOptimization(randomPath)));

	   System.out.println("The path generated by greedy optimization algorithm is: " + Arrays.toString(graph.greedyRandomOptimization(randomPath)));

	   Graph graph1000 = new Graph(new Vertex[1000], new Edge[1000][999]);
	   Graph graph2000 = new Graph(new Vertex[2000], new Edge[2000][1999]);
	   Graph graph5000 = new Graph(new Vertex[5000], new Edge[5000][4999]);
	   Graph graph10000 = new Graph(new Vertex[10000], new Edge[10000][9999]);

	   graph1000 = graph1000.graphGenerator(1000);
	   graph2000 = graph2000.graphGenerator(2000);
	   graph5000 = graph5000.graphGenerator(5000);
	   graph10000 = graph10000.graphGenerator(10000);

	   System.out.println("\n\n\nGraph with a 1000 cities has been generated. \nNow diffrent algorithms will be run with it:");
	   System.out.println("Ok? (1 for yes)");
	   Scanner input = new Scanner(System.in);
	   int s = input.nextInt();

	   int[] randomPath1000 = new int[1000];
	   randomPath1000 = graph1000.random().clone();

	   if(s == 1)
	   {
	 	  System.out.println("The path generated by random method is: " + Arrays.toString(randomPath1000));

	 	  graph1000.reset();
	   }

	   System.out.println("\nRandom method has been executed. Continue to Iterative? (1 for yes)");
	   s = input.nextInt();

	   if(s == 1)
	   {
	   		System.out.println("The best path generated by iterative method is: " + Arrays.toString(graph1000.iterative()) + "\n");

	   		graph1000.reset();
	   }

	   System.out.println("\nIterative method has been executed. Continue to Greedy? (1 for yes)");
	   s = input.nextInt();

	   if(s == 1)
	   {
	   		System.out.println("The path generated by greedy algorithm is: " + Arrays.toString(graph1000.greedy()));
	   }

	   System.out.println("\nGreedy method has been executed. Continue to Greedy Optimization? (1 for yes)");
	   s = input.nextInt();

	   if(s == 1)
	   {
	   		System.out.println("The path generated by greedy optimization algorithm is: " + Arrays.toString(graph1000.greedyOptimization(randomPath1000)));
	   }

	   System.out.println("\nGreedy optimization method has been executed. Continue to Greedy random optimization? (1 for yes)");
	   s = input.nextInt();

	   if(s == 1)
	   {
	   		System.out.println("The path generated by greedy optimization algorithm is: " + Arrays.toString(graph1000.greedyRandomOptimization(randomPath1000)));
	   }

	   System.out.println("The program has finished running successfully.");
   }
}

class Vertex
{
	int index;
	boolean visited;

	Vertex (int index, boolean visited)
	{
		this.index = index;
		this.visited = visited;
	}
}

class Edge
{
	int startIndex;
	int endIndex;
	int value;

	Edge (int startIndex, int endIndex, int value)
	{
		this.startIndex = startIndex;
		this.endIndex = endIndex;
		this.value = value;
	}
}

class Graph
{
	Vertex[] vertices;
	Edge[][] edges;

	Graph (	Vertex[] vertices, Edge[][] edges)
	{
		this.vertices = vertices;
		this.edges = edges;
	}

	public int[] random()
	{
		int[] randomPath = new int[vertices.length];
		int visited = 0;
		int randomVertexToGoTo = (int)(Math.random() * vertices.length);
		int cost = 0;

		Vertex current = vertices[randomVertexToGoTo];
		current.visited = true;
		randomPath[visited] = current.index;

		while(visited < vertices.length - 1)
		{
			randomVertexToGoTo = (int)(Math.random() * vertices.length);

			if(vertices[randomVertexToGoTo].index != current.index && vertices[randomVertexToGoTo].visited == false)
			{

				int i = 0;
				Edge theEdge = edges[current.index][i];

				while (edges[current.index][i].endIndex != randomVertexToGoTo)
				{
					i++;
					theEdge = edges[current.index][i];
				}

				vertices[randomVertexToGoTo].visited = true;
				cost += theEdge.value;
				visited++;
				current = vertices[randomVertexToGoTo];
				randomPath[visited] = randomVertexToGoTo;
			}
	    }

	    System.out.println("RANDOM METHOD");

	    return randomPath;
	}

	public void reset()
	{
	    for(int i = 0; i < vertices.length; i++)
	    {
			vertices[i].visited = false;
		}
	}

	public int[] iterative()
	{
		Scanner input = new Scanner(System.in);
		int count = 0;
		int svar = 1;
		int[] bestResult = new int[vertices.length];
		int minCost = 0;

		while(count < 10)
		{
			count++;

			int[] randomPath = new int[vertices.length];
			int visited = 0;
			int randomVertexToGoTo = (int)(Math.random() * vertices.length);
			int cost = 0;

			Vertex current = vertices[randomVertexToGoTo];
			current.visited = true;
			randomPath[visited] = current.index;

			while(visited < vertices.length - 1)
			{
				randomVertexToGoTo = (int)(Math.random() * vertices.length);

				if(vertices[randomVertexToGoTo].index != current.index && vertices[randomVertexToGoTo].visited == false)
				{
					int i = 0;
					Edge theEdge = edges[current.index][i];

					while (edges[current.index][i].endIndex != randomVertexToGoTo)
					{
						i++;
						theEdge = edges[current.index][i];
					}

					vertices[randomVertexToGoTo].visited = true;
					cost += theEdge.value;
					visited++;
					current = vertices[randomVertexToGoTo];
					randomPath[visited] = randomVertexToGoTo;
				}
	    	}

	    	if(count == 1)
	    	{
				System.out.println("\nITERATIVE METHOD");
				bestResult = randomPath;
				minCost = cost;
			}
			else if(cost < minCost && count != 1)
			{
				bestResult = randomPath;
				minCost = cost;
			}

			System.out.println("The best result found after " + count + " iteretions is: " + Arrays.toString(bestResult) + " and its cost is: " + minCost);

			reset();
		}

		return bestResult;
	}


	public int[] greedy()
	{
		int[] randomPath = new int[vertices.length];
		int visited = 0;
		int randomVertexToGoTo = (int)(Math.random() * vertices.length);
		int cost = 0;

		Vertex current = vertices[randomVertexToGoTo];
		current.visited = true;
		randomPath[visited] = current.index;

		while(visited < vertices.length - 1)
		{
			Edge theEdge = edges[current.index][0];

			Edge minEdge = theEdge;

			for(int k = 0; k < vertices.length - 1; k++)
			{
				theEdge = edges[current.index][k];

				if (vertices[theEdge.endIndex].visited != true)
				{
					minEdge = theEdge;
				}
			}

			for(int k = 0; k < vertices.length - 1; k++)
			{
				theEdge = edges[current.index][k];

				if (minEdge.value > theEdge.value && vertices[theEdge.endIndex].visited != true)
				{
					minEdge = theEdge;
				}
			}


			vertices[minEdge.endIndex].visited = true;
			cost += minEdge.value;
			visited++;
			current = vertices[minEdge.endIndex];
			randomPath[visited] = minEdge.endIndex;
		}

		System.out.println("GREEDY ALGORITHM \nCost of the path generated by greedy algorithm is: " + cost);

	    return randomPath;
	}

	public int[] greedyOptimization(int[] x)
	{
		System.out.println("\nGREEDY OPTIMIZATION \nInitial path: " + Arrays.toString(x));

		int[] optimizedPath = x.clone();

		for(int k = 0; k < 10; k++)
		{
			int[] holder = optimizedPath.clone();

			int cost = 0;

			for(int j = 0; j < optimizedPath.length - 1; j++)
			{

				int i = 0;
				Edge theEdge = edges[optimizedPath[j]][i];

				while (edges[optimizedPath[j]][i].endIndex != optimizedPath[j+1])
				{
					i++;
					theEdge = edges[optimizedPath[j]][i];
				}

				cost += theEdge.value;
			}

			if(k == 0)
			{
				System.out.println("Initial path cost: " + cost);
			}

			int c1, c2;

			do{
				c1 = (int)(Math.random() * x.length);
				c2 = (int)(Math.random() * x.length);
			}while (c1 == c2);

			int temp = x[c1];
			x[c1] = x[c2];
			x[c2] = temp;

			int newCost = 0;

			for(int j = 0; j < x.length - 1; j++)
			{

				int i = 0;
				Edge theEdge = edges[x[j]][i];

				while (edges[x[j]][i].endIndex != x[j+1])
				{
					i++;
					theEdge = edges[x[j]][i];
				}

				newCost += theEdge.value;
			}

			if(newCost < cost)
			{
				optimizedPath = x.clone();
			}
			else
			{
				optimizedPath = holder.clone();
			}

			if(k == 9)
			{
				System.out.println("Final path cost: " + cost);
			}
		}

	    return optimizedPath;
	}

	public int[] greedyRandomOptimization(int[] x)
	{
		System.out.println("\nGREEDY RANDOM OPTIMIZATION \nInitial path: " + Arrays.toString(x));

		int[] optimizedPath = x.clone();

		int[] bestPath = x.clone();

		int bestCost = 0;

		double PA = 0.9;

		int cost = 0;

			for(int j = 0; j < optimizedPath.length - 1; j++)
			{
				int i = 0;
				Edge theEdge = edges[optimizedPath[j]][i];
				while (edges[optimizedPath[j]][i].endIndex != optimizedPath[j+1])
				{
					i++;
					theEdge = edges[optimizedPath[j]][i];
				}
			cost += theEdge.value;
		    }

		System.out.println("Initial path cost: " + cost);

		int counter = 0;

		do
		{
			counter++;

			for(int k = 0; k < 10; k++)
			{
				int[] holder = optimizedPath.clone();

				cost = 0;

				for(int j = 0; j < optimizedPath.length - 1; j++)
				{

					int i = 0;
					Edge theEdge = edges[optimizedPath[j]][i];

					while (edges[optimizedPath[j]][i].endIndex != optimizedPath[j+1])
					{
						i++;
						theEdge = edges[optimizedPath[j]][i];
					}

					cost += theEdge.value;
				}

				bestCost = 0;

				for(int j = 0; j < bestPath.length - 1; j++)
				{

					int i = 0;
					Edge theEdge = edges[bestPath[j]][i];

					while (edges[bestPath[j]][i].endIndex != bestPath[j+1])
					{
						i++;
						theEdge = edges[bestPath[j]][i];
					}

					bestCost += theEdge.value;
				}

				int c1, c2;

				do{
					c1 = (int)(Math.random() * x.length);
					c2 = (int)(Math.random() * x.length);
				}while (c1 == c2);

				int temp = x[c1];
				x[c1] = x[c2];
				x[c2] = temp;

				int newCost = 0;

				for(int j = 0; j < x.length - 1; j++)
				{

					int i = 0;
					Edge theEdge = edges[x[j]][i];

					while (edges[x[j]][i].endIndex != x[j+1])
					{
						i++;
						theEdge = edges[x[j]][i];
					}

					newCost += theEdge.value;
				}

				if(newCost < cost)
				{
					optimizedPath = x.clone();

					if (newCost < bestCost)
					{
						bestPath = optimizedPath.clone();
					}
				}
				else
				{
					optimizedPath = holder.clone();

					double rnd = (double)(Math.random() * 100 / 100);
					if(rnd < PA)
					{
						optimizedPath = x.clone();
					}
				}
			}

			PA = PA * 0.9;

		}while(PA > 0.0000001);

		System.out.println("Probability of acceptance after " + counter + " iterations is: " + PA);

		System.out.println("Best path cost: " + bestCost);

	    return bestPath;
	}

	public Graph graphGenerator(int x)
	{
	   Vertex[] vertices = new Vertex[x];

	   for(int i = 0; i < x; i++)
	   {
	   	   	vertices[i] = new Vertex(i, false);
	   }

	   Edge[][] edges = new Edge[x][x-1];

		for(int i = 0; i < x; i++)
		{
			int[] v = new int[x-1];

			int f = 0;
			int g = 0;

			while(g < x-1)
			{
				if (f != i)
				{
					v[g] = f;
					g++;
				}
				f++;
			}

			for(int k = 0; k < x-1; k++)
			{
				int r = (int)(Math.random() * 10 + 1);

				edges[i][k] = new Edge(i, v[k], r);
			}
		}

	   Graph graph = new Graph(vertices, edges);

	   return graph;
	}
}